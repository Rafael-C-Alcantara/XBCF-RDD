library(devtools)
## Install latest version of XBART package if available
install_github("Rafael-C-Alcantara/XBART@XBCF-RDD")
library(XBART)
## Install latest version of HighDimRD package (KR)
install_github("kolesarm/RDHonest")
library(RDHonest)
install_github("akreiss/HighDimRD")
library(HighDimRD)
## Source code from FH
### install.packages(c("np","rdd","matrixStats","xtable","boot"))
source("R/FH.R")
## Helper functions
### Extract 95% CI and posterior mean from pred.XBCFrd
tau.pred <- function(x,burnin,num_sweeps)
{
    ate.posterior <- colMeans(x$tau.adj[,(burnin+1):num_sweeps])
    return(c(mean(ate.posterior),quantile(ate.posterior,c(.025,.975))))
}
### Return ATE prediction for XBCF-RDD
pred.ate.xbcf <- function()
{
    ## XBCF
    fit.XBCFrdd1 <- XBCF.rd(y, w, x, c, Owidth = Owidth, Omin = Omin, Opct = Opct,
                          pcat_con = 0, pcat_mod = 0,
                          num_trees_mod = num_trees_mod, num_trees_con = num_trees_con,
                          num_cutpoints = num_cutpoints, num_sweeps = num_sweeps,
                          burnin = burnin, Nmin = Nmin)

### Given the original (w,x) used for fitting the model, we take (w,x=0) as the test set
    pred1 <- predict.XBCFrd(fit.XBCFrd1, W = w, X = rep(0,n))

    ## ATE summary for pred.list
    return(tau.pred(pred,burnin,num_sweeps))
}
### Return available cutpoints at root node for a given Owidth
cutpoints <- function(Owidth)
{
    fit <- XBCF.rd(y, w, x, c, Owidth = Owidth, Omin = Omin, Opct = Opct,
                   pcat_con = 0, pcat_mod = 0,
                   num_trees_mod = 1, num_trees_con = 1,
                   num_cutpoints = num_cutpoints, num_sweeps = 1,
                   burnin = 0, Nmin = Nmin)
    trees_json <- jsonlite::fromJSON(fit$tree_json_mod,simplifyVector=F)
    return(trees_json$trees[["0"]][["0"]][["avail.cutpoints"]])
}
### Find minimum Owidth that leads to more than 1 available cutppoint at root noden
findOwidth <- function(seq)
{
    i <- 0.01
    ## Do this to avoid i s.t. there are no obs in the bandwidth
    while(sum(x>=-i & x<=i)<15) i <- i+0.01
    while(cutpoints(i)==1) i <- i+seq
    return(i)
}
### Plot results
resPlot <- function(x)
{
    plotMat <- do.call("cbind",lapply(x[-1],function(y) (y[,1]-x$ATE)^2))
    boxplot(plotMat)
}
### Table results
resTab <- function(x)
{
    return(colMeans(do.call("cbind",lapply(x[-1],function(y) (y[,1]-x$ATE)^2))))
}
## Settings
### Owidth: overlap bandiwdth (defined per data)
### Omin: minimum number of observations inside overlap region for each leaf node
### Opct: If nb is the number of obs in node b, Opct*nb of them have to be inside overlap region
mu <- function(W, X) return(0.1 * rowSums(W) + 1/(1+exp(-5*X)))
tau <- function(W, X) return( sin(mu(W, X)) + 1)
n <- 100
p <- 2
c <- 0 # Cutoff
Omin          <- 2
Opct          <- 0.9
num_trees_mod <- 10
num_trees_con <- 10
num_cutpoints <- n
Nmin          <- 10
num_sweeps    <- 20
burnin        <- 10
## Simulations
s <- 50 ## samples
###
results <- list("ATE"=vector("numeric",s),"XBCF-RDD"=matrix(0,s,3),
                "CGS"=NA,"KR"=matrix(0,s,3),"FH"=matrix(0,s,3))
cut <- vector("numeric",s)
h <- vector("numeric",s)
###
set.seed(000)
for (i in 1:s)
{
    print(paste0("Iteration: ",i))
    ###
    w <- matrix(rnorm(n*p), n, p)
    x <- rnorm(n,sd=.5)
    z <- x >= c
    y <- mu(w, x) + tau(w, x)*z + rnorm(n, 0, 0.1)
    ## Find minimum possible Owidth for that data
    Owidth <- findOwidth(0.01)
    cut[i] <- cutpoints(Owidth)
    h[i] <- Owidth
    ## Owidth <- 0.11
    ## Get interactions and expansions for KR
    w1 <- fourier_basis(w,4)
    w_HighDim <- cbind(w,interaction_terms(w),w1,interaction_terms(w1))
    ## Estimation
    ate.xbcf <- pred.ate.xbcf()
    ate.kr  <- HighDim_rd(y,x,w_HighDim,tpc="CV" ,rd="robust")
    ate.kr <- c(ate.kr$rd$Estimate[,"tau.bc"],
                ate.kr$rd$Estimate[,"tau.bc"]-1.96*ate.kr$rd$Estimate[,"se.rb"],
                ate.kr$rd$Estimate[,"tau.bc"]+1.96*ate.kr$rd$Estimate[,"se.rb"])
    ate.fh <- rdd.x(y,x,w)
    ## Store results
    results[["XBCF-RDD"]][i,] <- ate.xbcf
    results[["KR"]][i,] <- ate.kr
    results[["FH"]][i,] <- ate.fh
    results[["ATE"]][i] <- mean(tau(w,0))
}
## Load CGS results and merge
cgs <- readRDS("R/results_cgs.rds")
results[["CGS"]] <- cgs$CGS
saveRDS(results,"R/results.rds")
## Plot MSE
resPlot(results)
## Table MSE
resTab(results)
